//! Simplex elements
use super::{Cell, Edge, Face, Node, Tetrahedron, Triangle, twovec};
use crate::Vertex;
use nalgebra::{SMatrix, SVector};
use rustc_hash::FxHashMap;

/// Simplex elements
pub trait Simplex<const C: usize>: Sized {
    /// Get the dimension
    #[must_use]
    fn dim() -> usize {
        C - 1
    }

    /// Get the number of edges
    #[must_use]
    fn n_edges() -> usize {
        C * (C - 1) / 2
    }

    /// Get the number of faces
    #[must_use]
    fn n_faces() -> usize {
        C
    }

    /// Get the edges for the simplex `(0, .., C-1)`
    fn edges() -> Vec<Edge>;

    /// Get the i-th edge for the current simplex
    fn edge(&self, i: usize) -> Edge;

    /// Get the faces for the simplex `(0, .., C-1)`
    fn faces<const F: usize>() -> Vec<Face<F>>;

    /// Get the i-th face for the current simplex
    fn face<const F: usize>(&self, i: usize) -> Face<F>;

    /// Get the volume of a simplex
    fn vol<const D: usize>(v: &[Vertex<D>; C]) -> f64;

    /// Check if a normal can be computed in D dimensions
    #[must_use]
    fn has_normal<const D: usize>() -> bool {
        D == C
    }

    /// Normal to the vertex
    fn normal<const D: usize>(v: &[Vertex<D>; C]) -> Vertex<D>;

    /// Radius (=diameter of the inner circle / sphere)
    fn radius<const D: usize>(v: &[Vertex<D>; C]) -> f64;

    /// Get a quadrature (weights and points)
    fn quadrature() -> (Vec<f64>, Vec<Vec<f64>>);

    /// Sort the vertex indices
    #[must_use]
    fn sorted(&self) -> Self;

    /// Check of two elements are the same (allowing circular permutation)
    fn is_same(&self, other: &Self) -> bool;

    /// Invert the element
    fn invert(&mut self);

    /// Barycentric coordinates
    fn bcoords<const D: usize>(ge: &[Vertex<D>; C], v: &Vertex<D>) -> [f64; C];

    /// Vertex from barycentric coordinates
    fn vert<const D: usize>(ge: &[Vertex<D>; C], bcoords: [f64; C]) -> Vertex<D>;

    /// Gamma quality measure, ratio of inscribed radius to circumradius
    /// normalized to be between 0 and 1
    fn gamma<const D: usize>(ge: &[Vertex<D>; C]) -> f64;

    /// Project a point on the simplex
    fn project<const D: usize>(ge: &[Vertex<D>; C], v: &Vertex<D>) -> Vertex<D>;

    /// Try to project a point inside the simplex
    #[must_use]
    fn project_inside<const D: usize>(ge: &[Vertex<D>; C], v: &Vertex<D>) -> Option<Vertex<D>> {
        let bcoords = Self::bcoords(ge, v);
        if bcoords.iter().copied().all(|x| x > 0.0) {
            Some(Self::vert(ge, bcoords))
        } else {
            None
        }
    }

    /// Distance from a point to the simplex
    #[must_use]
    fn distance<const D: usize>(ge: &[Vertex<D>; C], v: &Vertex<D>) -> f64 {
        let pt = Self::project::<D>(ge, v);
        (v - pt).norm()
    }
}

impl Simplex<0> for [usize; 0] {
    fn edges() -> Vec<Edge> {
        unreachable!()
    }

    fn edge(&self, _i: usize) -> Edge {
        unreachable!()
    }

    fn faces<const F: usize>() -> Vec<Face<F>> {
        unreachable!()
    }

    fn face<const F: usize>(&self, _i: usize) -> Face<F> {
        unreachable!()
    }

    fn vol<const D: usize>(_v: &[Vertex<D>; 0]) -> f64 {
        unreachable!()
    }

    fn normal<const D: usize>(_v: &[Vertex<D>; 0]) -> Vertex<D> {
        unreachable!()
    }

    fn radius<const D: usize>(_v: &[Vertex<D>; 0]) -> f64 {
        unreachable!()
    }

    fn quadrature() -> (Vec<f64>, Vec<Vec<f64>>) {
        unreachable!()
    }

    fn sorted(&self) -> Self {
        unreachable!()
    }

    fn is_same(&self, _other: &Self) -> bool {
        unreachable!()
    }

    fn invert(&mut self) {}

    fn bcoords<const D: usize>(_ge: &[Vertex<D>; 0], _v: &Vertex<D>) -> [f64; 0] {
        unreachable!()
    }

    fn vert<const D: usize>(_ge: &[Vertex<D>; 0], _bcoords: [f64; 0]) -> Vertex<D> {
        unreachable!()
    }

    fn gamma<const D: usize>(_ge: &[Vertex<D>; 0]) -> f64 {
        unreachable!()
    }

    fn project<const D: usize>(_ge: &[Vertex<D>; 0], _v: &Vertex<D>) -> Vertex<D> {
        unreachable!()
    }
}

impl Simplex<1> for Node {
    fn edges() -> Vec<Edge> {
        unreachable!()
    }

    fn edge(&self, _i: usize) -> Edge {
        unreachable!()
    }

    fn faces<const F: usize>() -> Vec<Face<F>> {
        unreachable!()
    }

    fn face<const F: usize>(&self, _i: usize) -> Face<F> {
        unreachable!()
    }

    fn vol<const D: usize>(_v: &[Vertex<D>; 1]) -> f64 {
        unreachable!()
    }

    fn normal<const D: usize>(_v: &[Vertex<D>; 1]) -> Vertex<D> {
        unreachable!()
    }

    fn radius<const D: usize>(_v: &[Vertex<D>; 1]) -> f64 {
        unreachable!()
    }

    fn quadrature() -> (Vec<f64>, Vec<Vec<f64>>) {
        unreachable!()
    }

    fn sorted(&self) -> Self {
        *self
    }

    fn is_same(&self, other: &Self) -> bool {
        self[0] == other[0]
    }

    fn invert(&mut self) {}

    fn bcoords<const D: usize>(_ge: &[Vertex<D>; 1], _v: &Vertex<D>) -> [f64; 1] {
        unreachable!()
    }

    fn vert<const D: usize>(_ge: &[Vertex<D>; 1], _bcoords: [f64; 1]) -> Vertex<D> {
        unreachable!()
    }

    fn gamma<const D: usize>(_ge: &[Vertex<D>; 1]) -> f64 {
        1.0
    }

    fn project<const D: usize>(ge: &[Vertex<D>; 1], _v: &Vertex<D>) -> Vertex<D> {
        ge[0]
    }
}

pub const EDGE_FACES: [Node; 2] = [[0], [1]];

impl Simplex<2> for Edge {
    fn edges() -> Vec<Edge> {
        vec![[0, 1]]
    }

    fn edge(&self, i: usize) -> Edge {
        match i {
            0 => [self[0], self[1]],
            _ => unreachable!(),
        }
    }

    fn faces<const F: usize>() -> Vec<Face<F>> {
        debug_assert_eq!(F, 1);
        EDGE_FACES
            .iter()
            .map(|x| x.as_slice().try_into().unwrap())
            .collect()
    }

    fn face<const F: usize>(&self, i: usize) -> Face<F> {
        debug_assert_eq!(F, 1);
        let [i0] = EDGE_FACES[i];
        [self[i0]].as_slice().try_into().unwrap()
    }

    fn vol<const D: usize>(v: &[Vertex<D>; 2]) -> f64 {
        (v[1] - v[0]).norm()
    }

    fn normal<const D: usize>(v: &[Vertex<D>; 2]) -> Vertex<D> {
        if Self::has_normal::<D>() {
            Vertex::<D>::from_column_slice(&[v[1][1] - v[0][1], v[0][0] - v[1][0]])
        } else {
            unreachable!()
        }
    }

    fn radius<const D: usize>(v: &[Vertex<D>; 2]) -> f64 {
        0.5 * (v[1] - v[0]).norm()
    }

    fn quadrature() -> (Vec<f64>, Vec<Vec<f64>>) {
        let weights = vec![5.0 / 18.0, 8.0 / 18.0, 5.0 / 18.0];
        let pts = vec![
            vec![0.5 - 0.5 * (3.0_f64 / 5.0).sqrt()],
            vec![0.5],
            vec![0.5 + 0.5 * (3.0_f64 / 5.0).sqrt()],
        ];
        (weights, pts)
    }

    fn sorted(&self) -> Self {
        let mut tmp = *self;
        tmp.sort_unstable();
        tmp
    }

    fn is_same(&self, other: &Self) -> bool {
        *self == *other
    }

    fn invert(&mut self) {
        self.swap(1, 0);
    }

    fn bcoords<const D: usize>(ge: &[Vertex<D>; 2], v: &Vertex<D>) -> [f64; 2] {
        let ab = ge[1] - ge[0];
        let ap = v - ge[0];

        let ab_squared_magnitude = ab.norm_squared();
        let t = ap.dot(&ab) / ab_squared_magnitude;
        [1.0 - t, t]
    }

    fn vert<const D: usize>(ge: &[Vertex<D>; 2], bcoords: [f64; 2]) -> Vertex<D> {
        bcoords[0] * ge[0] + bcoords[1] * ge[1]
    }

    fn gamma<const D: usize>(_ge: &[Vertex<D>; 2]) -> f64 {
        1.0
    }

    fn project<const D: usize>(ge: &[Vertex<D>; 2], v: &Vertex<D>) -> Vertex<D> {
        Self::project_inside(ge, v).map_or_else(
            || {
                let p0 = Node::project(&[ge[0]], v);
                let d0 = (v - p0).norm_squared();
                let p1 = Node::project(&[ge[1]], v);
                let d1 = (v - p1).norm_squared();
                if d0 < d1 { p0 } else { p1 }
            },
            |pt| pt,
        )
    }
}

pub const TRIANGLE_FACES: [Edge; 3] = [[0, 1], [1, 2], [2, 0]];

impl Simplex<3> for Triangle {
    fn edges() -> Vec<Edge> {
        vec![[0, 1], [1, 2], [2, 0]]
    }

    fn edge(&self, i: usize) -> Edge {
        match i {
            0 => [self[0], self[1]],
            1 => [self[1], self[2]],
            2 => [self[2], self[0]],
            _ => unreachable!(),
        }
    }

    fn faces<const F: usize>() -> Vec<Face<F>> {
        debug_assert_eq!(F, 2);
        TRIANGLE_FACES
            .iter()
            .map(|x| x.as_slice().try_into().unwrap())
            .collect()
    }

    fn face<const F: usize>(&self, i: usize) -> Face<F> {
        debug_assert_eq!(F, 2);
        let [i0, i1] = TRIANGLE_FACES[i];
        [self[i0], self[i1]].as_slice().try_into().unwrap()
    }

    fn vol<const D: usize>(v: &[Vertex<D>; 3]) -> f64 {
        if Self::has_normal::<D>() {
            Self::normal(v).norm()
        } else {
            assert_eq!(D, 2);
            let e1 = v[1] - v[0];
            let e2 = v[2] - v[0];

            0.5 * (e1[0] * e2[1] - e1[1] * e2[0])
        }
    }

    fn normal<const D: usize>(v: &[Vertex<D>; 3]) -> Vertex<D> {
        if Self::has_normal::<D>() {
            let e1 = v[1] - v[0];
            let e2 = v[2] - v[0];
            0.5 * e1.cross(&e2)
        } else {
            unreachable!()
        }
    }

    fn radius<const D: usize>(v: &[Vertex<D>; 3]) -> f64 {
        let a = (v[2] - v[1]).norm();
        let b = (v[2] - v[0]).norm();
        let c = (v[1] - v[0]).norm();
        let s = 0.5 * (a + b + c);
        ((s - a) * (s - b) * (s - c) / s).sqrt()
    }

    fn quadrature() -> (Vec<f64>, Vec<Vec<f64>>) {
        let weights = vec![1. / 3., 1. / 3., 1. / 3.];
        let pts = vec![
            vec![2. / 3., 1. / 6.],
            vec![1. / 6., 2. / 3.],
            vec![1. / 6., 1. / 6.],
        ];
        (weights, pts)
    }

    fn sorted(&self) -> Self {
        let mut tmp = *self;
        tmp.sort_unstable();
        tmp
    }

    fn is_same(&self, other: &Self) -> bool {
        let [i0, i1, i2] = *self;
        *other == *self || *other == [i1, i2, i0] || *other == [i2, i0, i1]
    }

    fn invert(&mut self) {
        self.swap(1, 0);
    }

    fn bcoords<const D: usize>(ge: &[Vertex<D>; 3], v: &Vertex<D>) -> [f64; 3] {
        if D == 2 {
            let a = SMatrix::<f64, 3, 3>::new(
                1.0, 1.0, 1.0, ge[0][0], ge[1][0], ge[2][0], ge[0][1], ge[1][1], ge[2][1],
            );
            let b = SVector::<f64, 3>::new(1., v[0], v[1]);
            let decomp = a.lu();
            let x = decomp.solve(&b).unwrap();
            [x[0], x[1], x[2]]
        } else {
            let e0 = ge[1] - ge[0];
            let e1 = ge[2] - ge[0];
            let n = e0.cross(&e1);
            let w = v - ge[0];
            let nrm = n.norm_squared();
            let gamma = e0.cross(&w).dot(&n) / nrm;
            let beta = w.cross(&e1).dot(&n) / nrm;
            [1.0 - beta - gamma, beta, gamma]
        }
    }

    fn vert<const D: usize>(ge: &[Vertex<D>; 3], bcoords: [f64; 3]) -> Vertex<D> {
        ge[0] * bcoords[0] + ge[1] * bcoords[1] + ge[2] * bcoords[2]
    }

    fn gamma<const D: usize>(ge: &[Vertex<D>; 3]) -> f64 {
        let mut a = ge[2] - ge[1];
        let mut b = ge[0] - ge[2];
        let mut c = ge[1] - ge[0];

        a.normalize_mut();
        b.normalize_mut();
        c.normalize_mut();

        let cross_norm = |e1: &Vertex<D>, e2: &Vertex<D>| {
            if D == 2 {
                (e1[0] * e2[1] - e1[1] * e2[0]).abs()
            } else {
                let n = e1.cross(e2);
                n.norm()
            }
        };
        let sina = cross_norm(&b, &c);
        let sinb = cross_norm(&a, &c);
        let sinc = cross_norm(&a, &b);

        let tmp = sina + sinb + sinc;
        if tmp < 1e-12 {
            0.0
        } else {
            4.0 * sina * sinb * sinc / tmp
        }
    }

    fn project<const D: usize>(ge: &[Vertex<D>; 3], v: &Vertex<D>) -> Vertex<D> {
        Self::project_inside(ge, v).map_or_else(
            || {
                let p0 = Edge::project(&[ge[TRIANGLE_FACES[0][0]], ge[TRIANGLE_FACES[0][1]]], v);
                let d0 = (v - p0).norm_squared();
                let p1 = Edge::project(&[ge[TRIANGLE_FACES[1][0]], ge[TRIANGLE_FACES[1][1]]], v);
                let d1 = (v - p1).norm_squared();
                let p2 = Edge::project(&[ge[TRIANGLE_FACES[2][0]], ge[TRIANGLE_FACES[2][1]]], v);
                let d2 = (v - p2).norm_squared();
                if d0 < d1 && d0 < d2 {
                    p0
                } else if d1 < d2 {
                    p1
                } else {
                    p2
                }
            },
            |pt| pt,
        )
    }
}

pub const TETRA_FACES: [Triangle; 4] = [[1, 2, 3], [2, 0, 3], [0, 1, 3], [0, 2, 1]];
impl Simplex<4> for Tetrahedron {
    fn edges() -> Vec<Edge> {
        vec![[0, 1], [1, 2], [2, 0], [0, 3], [1, 3], [2, 3]]
    }

    fn edge(&self, i: usize) -> Edge {
        match i {
            0 => [self[0], self[1]],
            1 => [self[1], self[2]],
            2 => [self[2], self[0]],
            3 => [self[0], self[3]],
            4 => [self[1], self[3]],
            5 => [self[2], self[3]],
            _ => unreachable!(),
        }
    }

    fn faces<const F: usize>() -> Vec<Face<F>> {
        debug_assert_eq!(F, 3);
        TETRA_FACES
            .iter()
            .map(|x| x.as_slice().try_into().unwrap())
            .collect()
    }

    fn face<const F: usize>(&self, i: usize) -> Face<F> {
        debug_assert_eq!(F, 3);
        let [i0, i1, i2] = TETRA_FACES[i];
        [self[i0], self[i1], self[i2]]
            .as_slice()
            .try_into()
            .unwrap()
    }

    fn vol<const D: usize>(v: &[Vertex<D>; 4]) -> f64 {
        let e1 = v[1] - v[0];
        let e2 = v[2] - v[0];
        let e3 = v[3] - v[0];

        e3.dot(&e1.cross(&e2)) / 6.0
    }

    fn normal<const D: usize>(_v: &[Vertex<D>; 4]) -> Vertex<D> {
        unreachable!()
    }

    fn radius<const D: usize>(v: &[Vertex<D>; 4]) -> f64 {
        let a0 = Triangle::vol(&[v[0], v[1], v[2]]);
        let a1 = Triangle::vol(&[v[0], v[1], v[3]]);
        let a2 = Triangle::vol(&[v[1], v[2], v[3]]);
        let a3 = Triangle::vol(&[v[2], v[0], v[3]]);
        let v = Self::vol(v);
        3.0 * v / (a0 + a1 + a2 + a3)
    }

    fn quadrature() -> (Vec<f64>, Vec<Vec<f64>>) {
        let weights = vec![0.25, 0.25, 0.25, 0.25];
        let pts = vec![
            vec![0.1381966011250105, 0.1381966011250105, 0.1381966011250105],
            vec![0.5854101966249685, 0.1381966011250105, 0.1381966011250105],
            vec![0.1381966011250105, 0.5854101966249685, 0.1381966011250105],
            vec![0.1381966011250105, 0.1381966011250105, 0.5854101966249685],
        ];
        (weights, pts)
    }

    fn sorted(&self) -> Self {
        let mut tmp = *self;
        tmp.sort_unstable();
        tmp
    }

    fn is_same(&self, other: &Self) -> bool {
        let f = [self[1], self[2], self[3]];
        other.iter().position(|&x| x == self[0]).is_some_and(|i| {
            let o = [
                other[TETRA_FACES[i][0]],
                other[TETRA_FACES[i][1]],
                other[TETRA_FACES[i][2]],
            ];
            f.is_same(&o)
        })
    }

    fn invert(&mut self) {
        self.swap(1, 0);
    }

    fn bcoords<const D: usize>(ge: &[Vertex<D>; 4], v: &Vertex<D>) -> [f64; 4] {
        let a = SMatrix::<f64, 4, 4>::new(
            1.0, 1.0, 1.0, 1.0, ge[0][0], ge[1][0], ge[2][0], ge[3][0], ge[0][1], ge[1][1],
            ge[2][1], ge[3][1], ge[0][2], ge[1][2], ge[2][2], ge[3][2],
        );
        let b = SVector::<f64, 4>::new(1., v[0], v[1], v[2]);
        let decomp = a.lu();
        let x = decomp.solve(&b).unwrap();
        [x[0], x[1], x[2], x[3]]
    }

    fn vert<const D: usize>(ge: &[Vertex<D>; 4], bcoords: [f64; 4]) -> Vertex<D> {
        ge[0] * bcoords[0] + ge[1] * bcoords[1] + ge[2] * bcoords[2] + ge[3] * bcoords[3]
    }

    fn gamma<const D: usize>(ge: &[Vertex<D>; 4]) -> f64 {
        let vol = Self::vol(ge);
        if vol < f64::EPSILON {
            return 0.0;
        }

        let a = ge[1] - ge[0];
        let b = ge[2] - ge[0];
        let c = ge[3] - ge[0];

        let aa = ge[3] - ge[2];
        let bb = ge[3] - ge[1];
        let cc = ge[2] - ge[1];

        let la = a.norm_squared();
        let lb = b.norm_squared();
        let lc = c.norm_squared();
        let laa = aa.norm_squared();
        let lbb = bb.norm_squared();
        let lcc = cc.norm_squared();

        let lalaa = (la * laa).sqrt();
        let lblbb = (lb * lbb).sqrt();
        let lclcc = (lc * lcc).sqrt();

        let tmp = (lalaa + lblbb + lclcc)
            * (lalaa + lblbb - lclcc)
            * (lalaa - lblbb + lclcc)
            * (-lalaa + lblbb + lclcc);

        // This happens when the 4 points are (nearly) co-planar
        // => R is actually undetermined but the quality is (close to) zero
        if tmp < f64::EPSILON {
            return 0.0;
        }

        let r = tmp.sqrt() / 24.0 / vol;

        let s1 = Face::<3>::vol(&[
            ge[TETRA_FACES[0][0]],
            ge[TETRA_FACES[0][1]],
            ge[TETRA_FACES[0][2]],
        ]);
        let s2 = Face::<3>::vol(&[
            ge[TETRA_FACES[1][0]],
            ge[TETRA_FACES[1][1]],
            ge[TETRA_FACES[1][2]],
        ]);
        let s3 = Face::<3>::vol(&[
            ge[TETRA_FACES[2][0]],
            ge[TETRA_FACES[2][1]],
            ge[TETRA_FACES[2][2]],
        ]);
        let s4 = Face::<3>::vol(&[
            ge[TETRA_FACES[3][0]],
            ge[TETRA_FACES[3][1]],
            ge[TETRA_FACES[3][2]],
        ]);
        let rho = 9.0 * vol / (s1 + s2 + s3 + s4);

        rho / r
    }

    fn project<const D: usize>(ge: &[Vertex<D>; 4], v: &Vertex<D>) -> Vertex<D> {
        Self::project_inside(ge, v).map_or_else(
            || {
                let p0 = Triangle::project(
                    &[
                        ge[TETRA_FACES[0][0]],
                        ge[TETRA_FACES[0][1]],
                        ge[TETRA_FACES[0][2]],
                    ],
                    v,
                );
                let d0 = (v - p0).norm_squared();
                let p1 = Triangle::project(
                    &[
                        ge[TETRA_FACES[1][0]],
                        ge[TETRA_FACES[1][1]],
                        ge[TETRA_FACES[1][2]],
                    ],
                    v,
                );
                let d1 = (v - p1).norm_squared();
                let p2 = Triangle::project(
                    &[
                        ge[TETRA_FACES[2][0]],
                        ge[TETRA_FACES[2][1]],
                        ge[TETRA_FACES[2][2]],
                    ],
                    v,
                );
                let d2 = (v - p2).norm_squared();
                let p3 = Triangle::project(
                    &[
                        ge[TETRA_FACES[3][0]],
                        ge[TETRA_FACES[3][1]],
                        ge[TETRA_FACES[3][2]],
                    ],
                    v,
                );
                let d3 = (v - p3).norm_squared();
                if d0 < d1 && d0 < d2 && d0 < d3 {
                    p0
                } else if d1 < d2 && d1 < d3 {
                    p1
                } else if d2 < d3 {
                    p2
                } else {
                    p3
                }
            },
            |pt| pt,
        )
    }
}

/// Compute a `FxHashMap` that maps face-to-vertex connectivity (sorted) to a vector of element indices
#[must_use]
pub fn get_face_to_elem<
    'a,
    const C: usize,
    const F: usize,
    I: ExactSizeIterator<Item = &'a Cell<C>>,
>(
    elems: I,
) -> FxHashMap<Face<F>, twovec::Vec<usize>>
where
    Cell<C>: Simplex<C>,
{
    let mut map: FxHashMap<Face<F>, twovec::Vec<usize>> = FxHashMap::default();
    for (i_elem, elem) in elems.enumerate() {
        for i_face in 0..Cell::<C>::n_faces() {
            let mut f = elem.face(i_face);
            f.sort_unstable();
            let n = map.get_mut(&f);
            if let Some(n) = n {
                n.push(i_elem);
            } else {
                map.insert(f, twovec::Vec::with_single(i_elem));
            }
        }
    }

    map
}

#[cfg(test)]
mod tests {
    use rand::{SeedableRng, rngs::StdRng, seq::SliceRandom};

    use crate::{
        Vert2d, Vert3d,
        mesh::{Simplex, Tetrahedron, Triangle},
    };

    #[test]
    fn test_is_same() {
        let e = [10, 12];
        let o = [10, 10];
        assert!(!e.is_same(&o));
        let o = [12, 10];
        assert!(!e.is_same(&o));
        let o = [10, 12];
        assert!(e.is_same(&o));

        let pts = [
            Vert3d::new(0.0, 0.0, 0.0),
            Vert3d::new(1.0, 0.0, 0.0),
            Vert3d::new(0.0, 1.0, 0.0),
            Vert3d::new(0.0, 0.0, 1.0),
        ];

        let gt = |e: &Triangle| [pts[e[0]], pts[e[1]], pts[e[2]]];
        let e = [0, 1, 2];
        let mut o = e;

        let mut rng = StdRng::seed_from_u64(1234);
        for _ in 0..10 {
            o.shuffle(&mut rng);
            let is_same = e.is_same(&o);
            let n = Triangle::normal(&gt(&o));
            if is_same {
                assert!(n[2] > 0.0);
            } else {
                assert!(n[2] < 0.0);
            }
        }

        let gt = |e: &Tetrahedron| [pts[e[0]], pts[e[1]], pts[e[2]], pts[e[3]]];
        let e = [0, 1, 2, 3];
        let mut o = e;

        for _ in 0..10 {
            o.shuffle(&mut rng);
            let is_same = e.is_same(&o);
            let n = Tetrahedron::vol(&gt(&o));
            if is_same {
                assert!(n > 0.0);
            } else {
                assert!(n < 0.0);
            }
        }
    }

    #[test]
    fn test_project_triangle() {
        let p0 = Vert3d::new(0.0, 0.0, 0.0);
        let p1 = Vert3d::new(1.0, 0.0, 0.0);
        let p2 = Vert3d::new(0.0, 1.0, 0.0);

        let ge = [p0, p1, p2];

        let p = Vert3d::new(-1.0, -1.0, 1.0);
        let proj = Triangle::project(&ge, &p);
        assert!((proj - Vert3d::new(0.0, 0.0, 0.0)).norm() < 1e-12);

        let p = Vert3d::new(2.0, -1.0, 1.0);
        let proj = Triangle::project(&ge, &p);
        assert!((proj - Vert3d::new(1.0, 0.0, 0.0)).norm() < 1e-12);

        let p = Vert3d::new(-2.0, 3.0, -1.0);
        let proj = Triangle::project(&ge, &p);
        assert!((proj - Vert3d::new(0.0, 1.0, 0.0)).norm() < 1e-12);

        let p = Vert3d::new(0.5, -2.0, -1.0);
        let proj = Triangle::project(&ge, &p);
        assert!((proj - Vert3d::new(0.5, 0.0, 0.0)).norm() < 1e-12);

        let p = Vert3d::new(-10.0, 0.2, 1.0);
        let proj = Triangle::project(&ge, &p);
        assert!((proj - Vert3d::new(0.0, 0.2, 0.0)).norm() < 1e-12);

        let p = Vert3d::new(1.2, 0.6, 3.0);
        let proj = Triangle::project(&ge, &p);
        assert!((proj - Vert3d::new(0.8, 0.2, 0.0)).norm() < 1e-12);

        let p = 0.1 * p0 + 0.2 * p1 + 0.7 * p2;
        let proj = Triangle::project(&ge, &p);
        assert!((proj - p).norm() < 1e-12);

        let proj = Triangle::project(&ge, &(p + Vert3d::new(0.0, 0.0, 2.0)));
        assert!((proj - p).norm() < 1e-12);
    }

    #[test]
    fn test_project_triangle_2d() {
        let p0 = Vert2d::new(0.0, 0.0);
        let p1 = Vert2d::new(1.0, 0.0);
        let p2 = Vert2d::new(0.0, 1.0);

        let ge = [p0, p1, p2];

        let p = Vert2d::new(-1.0, -1.0);
        let proj = Triangle::project(&ge, &p);
        assert!((proj - Vert2d::new(0.0, 0.0)).norm() < 1e-12);

        let p = Vert2d::new(2.0, -1.0);
        let proj = Triangle::project(&ge, &p);
        assert!((proj - Vert2d::new(1.0, 0.0)).norm() < 1e-12);

        let p = Vert2d::new(-2.0, 3.0);
        let proj = Triangle::project(&ge, &p);
        assert!((proj - Vert2d::new(0.0, 1.0)).norm() < 1e-12);

        let p = Vert2d::new(0.5, -2.0);
        let proj = Triangle::project(&ge, &p);
        assert!((proj - Vert2d::new(0.5, 0.0)).norm() < 1e-12);

        let p = Vert2d::new(-10.0, 0.2);
        let proj = Triangle::project(&ge, &p);
        assert!((proj - Vert2d::new(0.0, 0.2)).norm() < 1e-12);

        let p = Vert2d::new(1.2, 0.6);
        let proj = Triangle::project(&ge, &p);
        assert!((proj - Vert2d::new(0.8, 0.2)).norm() < 1e-12);

        let p = 0.1 * p0 + 0.2 * p1 + 0.7 * p2;
        let proj = Triangle::project(&ge, &p);
        assert!((proj - p).norm() < 1e-12);
    }
}
